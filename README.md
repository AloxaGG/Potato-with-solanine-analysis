ВВЕДЕНИЕ

Способности и возможности людей обрабатывать информацию ограничены, особенно в условиях возрастающих объёмов информации, поэтому появилась потребность использовать способы хранения, обработки и передачи информации (информационные технологии), отчуждённые от человека. Исходя из этого с каждым годом популярность информационных технологий растет и затрагивает различные сферы жизни человека. 
В 1959 году была создана первая программа по игре в шашки, которая умела играть сама с собой и обучаться самостоятельно. С этого момента и началась история машинного обучения. В 2011 году Google основал Google Brain — подразделение, занимавшееся проектами в области ИИ. Спустя ещё три года свои платформы по машинному обучению появились у Amazon и Microsoft, а Facebook внедрила в работу DeepFace — алгоритм, умеющий распознавать человеческие лица.
Итак, машинное обучение – это раздел искусственного интеллекта (ИИ) и информатики, который помогает компьютеру обучаться без непосредственных инструкций. Машинное обучение является важным компонентом растущей области науки о данных. Благодаря машинному обучению компьютеры учатся распознавать на фотографиях и рисунках не только лица, но и пейзажи, предметы, текст и цифры. Более того, уже существует программное обеспечение, способное без участия человека писать новостные статьи (на тему экономики и, к примеру, спорта).
Задачи машинного обучения делятся на 2 вида: 
- обучение без учителя.
Пример обучения без учителя - задача кластеризации.

- обучение с учителем, примером которого является задача классификации изображений. Данный метод предполагает, что модели будет известен правильный ответ.
Постановка задачи:
1)	Предварительный сбор данных (составление датасета) из изображений, разделение их по видам.
2)	Создание набора данных для тестирования.
3)	Создание нейронной сети.
4)	Компиляция модели и ее обучение.
5)	Оценка качества обучения и проверка.

	Для своих целей я буду использовать библиотеку TensorFlow языка Python и пакет, работающий с данной библиотекой Keras.
	Актуальность данной работы на сегодняшний день достаточно высока. Ввиду сложности ручной оценки качества картофеля, куда легче автоматизировать данный процесс, например на конвейере после сбора урожая, поэтому данная нейронная сеть может стать незаменимым помощником на фермах, выращивающих картофель.
	Данная идея не нова и уже используется на многих фермах и производствах, реализующих производство или подготовку к продаже картофеля и не только.
	На практике данный метод может показывать очень хороший результат и с вероятностью вплоть до 99% определять ядовитый картофель.

Глава 1. Необходимые библиотеки
1.1 TensorFlow, Keras и YOLO

	На сегодняшний день большинство задач по распознаванию изображений используют либо TensorFlow в связке с Keras или используют YOLO. Так как YOLO написана на языке С++ и для работы требует наличие в графическом процессоре Nvidia Cuda ядра, работа с ней требует специфических условий и оборудования, это и стало для меня причиной отказа от ее использования. Из преимуществ YOLO можно отметить ее быстродействие в реальном времени. 

	В отличии от YOLO, TensorFlow – встроенная в Pyhon библиотека и, так как обучение в нашем вузе происходит именно на нем, выбор стал очевиден.

	TensorFlow — это библиотека для машинного обучения, группы технологий, которая позволяет обучать искусственный интеллект решению разных задач. Библиотека изначально разработана для Python и чаще всего используется с ним.

	Существуют реализации TensorFlow для других языков: C#, C++, Go, Java, Swift и так далее. Они используются реже основной — главным образом для написания кода под специфичные платформы. Сама библиотека написана на языке Python с использованием быстрого и производительного C++ для решения математических задач. Поэтому она эффективно работает со сложными вычислениями.
Библиотека разработана Google как продолжение внутренней библиотеки компании. TensorFlow бесплатна, у нее открытый исходный код, который можно просмотреть на GitHub.
	Сама библиотека включает в себя множество инструментов для разных направлений ML, но чаще всего используется для работы с нейронными сетями. Это структуры, вдохновленные устройством сетей нейронов в человеческой нервной системе. Нейронные сети состоят из программных элементов-«нейронов» и связей между ними, и такое устройство позволяет им обучаться. TensorFlow работает с обычными и глубокими нейронными сетями разных типов: рекуррентными, сверточными и так далее. Также она используется для машинного и глубокого обучения.
	Примеры использования технологий — распознавание естественного языка, изображений и рукописных текстов, разнообразные задачи классификации или кластеризации, обработка больших данных.

	Keras — это библиотека для языка программирования Python, которая предназначена для глубокого машинного обучения. Она позволяет быстрее создавать и настраивать модели — схемы, по которым распространяется и подсчитывается информация при обучении. Но сложных математических вычислений Keras не выполняет и используется как надстройка над другими библиотеками.
	Keras с версии 2.3 — это надстройка над библиотекой TensorFlow, которая нужна для машинного обучения. TensorFlow выполняет все низкоуровневые вычисления и преобразования и служит своеобразным движком, математическим ядром. Keras же управляет моделями, по которым проходят вычисления.
	До версии 2.3 Keras мог использовать в качестве движка вычислительные библиотеки Theano или CNTK. Но в новых версиях поддержка прекратилась, теперь библиотека работает только с TensorFlow.

1.2 Какие методы будем использовать.
	В процессе работы мы создадим и обучим сверточную нейронную сеть. Сonvolutional neural network (CNN, ConvNet), или Сверточная нейронная сеть — класс глубоких нейронных сетей, часто применяемый в анализе визуальных образов. Сверточные нейронные сети являются разновидностью многослойного персептрона с использованием операций свёртки. Они нашли применение в распознавании изображений и видео, рекомендательных системах, классификации изображений, NLP (natural language processing) и анализе временных рядов.
Принцип работы операции свертки:
Операцию свёртки можно представить следующим алгоритмом:
Скользящее окно, называемое фильтром, с размером (n,n) двигается по входному признаку. Количество движений определяется заданным количеством фильтров.
Каждый полученный шаблон имеет форму (n,n,d), где d — глубина входного признака.
Каждый шаблон умножается на своё ядро свёртки, в результате, формируется выходная карта признаков. Полученная выходная карта признаков имеет форму (h,w,N), где h и w — длина и ширина, полученные в результате отсечения, а N — количество фильтров.
Количество фильтров — гиперпараметр, поэтому выбирается самостоятельно. Обычно его подбирают как степень двойки с увеличением количества фильтров по мере увеличения глубины архитектуры. А ядра свёртки являются обучаемыми параметрами.
Преобразование выходной карты признаков convolutional neural network (сверточные нейронные сети)
 ![image](https://github.com/AloxaGG/Potato-with-solanine-analysis/assets/114292403/aef68007-8c01-47fe-aa1d-f0549ca593dd)

Рисунок 1.1 Принцип действия операция свёртки.
На сегодняшний день практически все задачи по распознованию изображений используют именно этот метод.
Глава 2. Предварительный анализ данных, сбор информации, а также построение и обучение модели нейронной сети.
2.1 Подготовка данных и описание датасета
 	Цель данной курсовой работы является собрать достаточное количество фотографий клубней картофеля с соланином и без и обучить машину понимать, здоровая ли перед ней картошка или ядовитая. 
	Данная нейронная сеть могла бы очень помочь на ферме, где после сбора урожая требуется отделить ядовитые клубни от здоровых.
	Первое, что необходимо сделать – это найти достаточное количество фотографий (не менее ста экземпляров каждого типа). 
	Для сбора фотографий я воспользовался поисковиком Yandex  и скачал по соответствующим запросам по 108 картинок картофеля с соланином и без. Итоговые виды датасетов выглядят так:
 ![image](https://github.com/AloxaGG/Potato-with-solanine-analysis/assets/114292403/cf61b61f-2d28-48e4-8631-96ccc5e733f1)

Рисунок 2.1 Вид датасета картофеля с соланином.
 ![image](https://github.com/AloxaGG/Potato-with-solanine-analysis/assets/114292403/4597dfed-9588-4873-bb67-5cfe40aa9724)

Рисунок 2.2 Вид датасета здорового картофеля.
	Итого имеем: 
108 изображений картофеля с соланином.
108 изображений картофеля без соланина.

	Проведем подготовку датасета для обучения нейронной сети. Для начала установим константы banch_size – размер мини выборки в 16 единиц и image_size – размер изображений 100x100 пикселей. После чего подготовим изображения к работе, разбив их по директориям с выборкой для обучения и тестирования.
 ![image](https://github.com/AloxaGG/Potato-with-solanine-analysis/assets/114292403/b70852c1-3047-4ae3-8be6-9cc325b97b15)

Рисунок 2.3 Итоговый вид файловой системы.

	Для загрузки изображений в TensorFlow будем использовать утилиту image_dataset_from_directory(). Эта утилита создает TensorFlow датасет из каталога с изображениями, которые имеют специфическую структуру, где изображения одного класса находятся в одном каталоге. Наш набор данных устроен именно так:
 ![image](https://github.com/AloxaGG/Potato-with-solanine-analysis/assets/114292403/0d6b2bb2-434e-4443-96be-16fd9cf76a61)

Рисунок 2.4 Создание набора данных для обучения и тестирования.

	Нам для обучения нейронной сети нужно 3 набора данных: для обучения, для тестирования и для проверки, поэтому набор данных для обучения мы делим на 2 части. Для этого, когда мы вызываем утилиту image_dataset_from_directory(), мы указываем параметр validation_split именно он говорит о том, что 10 процентов набора данных для обучения будет использоваться в качестве проверочного набора данных. Указываем какой набор мы хотим создать (Для обучения “training”, для проверки “validation”), начальное значение seed для генератора случайных чисел, его обязательно использовать, если мы делим набор данных на две части для обучения и для проверки, так как набор данных перемешивается, нам необходимо выполнять операции одинаковым образом, когда мы вызываем утилиту image_dataset_from_directory() для создания обучающего и проверочного наборов данных. Указываем размер мини выборки batch_size. Наборы данных в TensorFlow расчитаны на работу с большим объемом данных, который не помещается в память, поэтому изображения не прочитаются в память целиком, а прочитается столько, сколько мы указали в размере мини выборки batch_size. В конце указываем размер изображений 100x100.
 ![image](https://github.com/AloxaGG/Potato-with-solanine-analysis/assets/114292403/3e9eca2e-d5f1-4100-98a4-1c0fb841e329)

Рисунок 2.5 Примеры изображений из созданного датасета.

	После создания обучающего и проверяющего датасетов создаем тестирующий датасет почти таким же образом, но без указания seed, validation_split и subset.

2.2 Создание нейронной сети
	Для того, чтобы ускорить скорость обучения необходимо настроить производительность TensorFlow датасетов. Вызываем метод prefetch, это означает, что будет выполнена предварительная загрузка нескольких мини выборок до того, как они понадобятся. Загрузка данных с диска – очень медленная операция, поэтому имеет смысл в то время, как графический процессор используется для обучения нейронной сети применять центральный процессор для того, чтобы загрузить данные с диска. Выполняем автоматическую настройку, теперь наши наборы данных готовы и настроены, и мы можем создавать нейронную сеть для распознавания картофеля с соланином из набора данных.
 ![image](https://github.com/AloxaGG/Potato-with-solanine-analysis/assets/114292403/0645912d-11db-4f51-9c13-07e149fcfe40)

Рисунок 2.6 Настройка производительности TensorFlow датасетов.

	Архитектуру нейронной сети я взял из статьи авторов, в которой описан набор данных, архитектура достаточно традиционная, в ней чередующиеся сверточные слои и слои подвыборки в размерах на свертке 5х5. В конце находится полносвязная часть для классификации и количество нейронов – 2 по количеству классов в исходном наборе данных.
 ![image](https://github.com/AloxaGG/Potato-with-solanine-analysis/assets/114292403/a9cb4dbb-8e28-4c8e-8e22-5d2d46f464fd)

Рисунок 2.7 Создание нейронной сети.

	После создания нейронной сети ее необходимо скомпилировать.
 ![image](https://github.com/AloxaGG/Potato-with-solanine-analysis/assets/114292403/b8ead7e4-d669-4ba0-83bd-b01ee944dc30)

Рисунок 2.8 Компиляция нейронной сети.

	И теперь мы готовы к обучению нейронной сети. В метод fit() мы передаем набор данных для обучения train_dataset. Здесь один датасет содержит как изображения, так и правильные ответы. В качестве проверочного набора данных validation_data передаем проверочный набор данных validation_dataset, который так же содержит как изображения из проверочного набора данных, так и правильные ответы. Количество эпох обучения epochs равное 15. Размер мини выборки мы не указываем, так как его мы его указали при создании наборов данных. Запускаем обучение.
 ![image](https://github.com/AloxaGG/Potato-with-solanine-analysis/assets/114292403/6f99ba73-fefc-4689-a198-4f758ef2b817)

Рисунок 2.9 Обучение нейронной сети.

	После обучения нейронной сети видно, что доля правильных ответов val_accuracy равна 0.8889.

2.3 Оценка качества обучения нейронной сети.
	Для оценки качества работы нейросети на тестовом наборе данных вызываем метод model.evaluate() и передаем в него тестовый набор данных. Тестовый набор данных содержит изображения и правильные ответы так же как наборы данных для обучения и проверки. Итак мы можем видеть, что доля правильных ответов на тестовом наборе данных равна 88.23%, что весьма неплохо для столь малого изначального датасета.
 ![image](https://github.com/AloxaGG/Potato-with-solanine-analysis/assets/114292403/5c2fedd3-870c-4d21-bf94-c5c89ff8bbac)

Рисунок 2.10 Оценка качества обучения.

	Для наглядности построим графики правильных ответов и ошибки на обучающем и проверочном наборе данных.
 ![image](https://github.com/AloxaGG/Potato-with-solanine-analysis/assets/114292403/720a7bef-126c-44bc-8d1c-4064734e0643)

Рисунок 2.11 Доля верных ответов.
 ![image](https://github.com/AloxaGG/Potato-with-solanine-analysis/assets/114292403/61173eae-d80b-4ceb-8151-4cc633bb10aa)

Рисунок 2.12 Доля ошибочных ответов.


2.4 Использование готовой нейронной сети для распознавания изображений.
	Для начала распознаем изображения из тестового набора данных, используя метод model.predict().
 ![image](https://github.com/AloxaGG/Potato-with-solanine-analysis/assets/114292403/53b7e70f-d156-4fe4-9960-95cd6782fe16)

Рисунок 2.13.1 Распознавание изображений из тестового набора данных.
 ![image](https://github.com/AloxaGG/Potato-with-solanine-analysis/assets/114292403/5d3adf47-f43d-4447-a7a3-282df920b149)

Рисунок 2.13.2 Распознавание изображений из тестового набора данных.

Видно как нейросеть распознает последовательно каждое изображение. Теперь выберем случайное одно изображение из тестового набора данных и распознаем его, после чего выведем это изображение на экран для проверки. 
![image](https://github.com/AloxaGG/Potato-with-solanine-analysis/assets/114292403/237216f0-7a5d-49dc-858a-f22d80ed88cd)

Рисунок 2.14 Распознавание случайного изображения.

Из результатов мы видим, что нейросеть справилась на отлично и определила правильно, так как на изображение и правда зеленый картофель с соланином.

2.5 Анализ результатов.
	Чтобы проанализировать работу нейросети на нестандартных данных подготовим 2 тестовых датасета, состоящих из 20 изображений каждый:
1.	Картофель без соланина с частичным его перекрытием зеленым листом. В качестве картофеля с соланином возьмем обычный картофель с соланином.
2.	Картофель без соланина, покрытый грязью. В качестве картофеля с соланином возьмем обычный картофель с соланином.
Итоговый вид датасетов:
 ![image](https://github.com/AloxaGG/Potato-with-solanine-analysis/assets/114292403/45d017c6-ad56-4969-84c2-c4c203e42437)

Рисунок 2.15 Вид датасета с перекрытием листвой.
 ![image](https://github.com/AloxaGG/Potato-with-solanine-analysis/assets/114292403/d156cfea-5fe8-4b84-9bbc-4cc746eca2e2)

Рисунок 2.16 Вид датасета покрытого грязью картофеля.

Теперь оценим качество работы нейросети на данных созданных датасетов.
 ![image](https://github.com/AloxaGG/Potato-with-solanine-analysis/assets/114292403/1ac988da-56f1-4937-891e-7cccc53dddb1)

Рисунок 2.15.1 Оценка качества на датасете с перекрытием листвой.
 ![image](https://github.com/AloxaGG/Potato-with-solanine-analysis/assets/114292403/2a7afce6-b9c3-4637-ae81-af48b414f115)

Рисунок 2.15.2 Оценка качества на датасете с перекрытием листвой.
![image](https://github.com/AloxaGG/Potato-with-solanine-analysis/assets/114292403/09c2260d-afdb-446f-bbf3-73c440cfd73f)
 
Рисунок 2.16.1 Оценка качества на датасете с грязным картофелем.
 ![image](https://github.com/AloxaGG/Potato-with-solanine-analysis/assets/114292403/10828821-81be-449a-bc04-809fe312d156)

Рисунок 2.16.2 Оценка качества на датасете с грязным картофелем.

	Из результатов мы видим, что нейросеть на датасете с перекрытием листвой дает правильный ответ в 85% случаях, а на датасете с грязным картофелем дает верный ответ в 75% случаях. 
	Данный результат далек от идеала, но данную проблему можно решить, включив в датасет для обучения соответствующие фотографии.
Итого имеем:
1.	Для правильных ответов на тестовом датасете: 88%
2.	Для правильных ответов на датасете с перекрытием листвой: 85%
3.	Для правильных ответов на датасете с грязным картофелем: 75%
Заключение
	В результате проделанной работы был подготовлен набор данных, на которых была обучена нейросеть для распознавания картофеля с соланином и без. Для решения поставленной задачи была использована библиотека TensorFlow  и ее пакет Keras. На выходе нейросеть показала достаточно неплохой результат в 88 процентов правильных ответов для своего относительно небольшого набора данных в 216 изображений картофеля с соланином и без. Была произведена проверка работы нейросети на примере.
